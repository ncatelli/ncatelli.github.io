<!doctype html><html lang=en-us><head><title>Intro to BGP with BIRD | Nate Catelli's Blog</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="An introductory tutorial on BGP using BIRD and docker."><meta name=generator content="Hugo 0.101.0"><meta name=ROBOTS content="INDEX, FOLLOW"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon></head><body><nav class=navigation><a href=/><span class=arrow>‚Üê</span>Home</a>
<a href=/posts>Archive</a>
<a href=/tags>Tags</a>
<a href=/about>About</a>
<a href=/projects>Projects</a>
<a href=/misc>Misc</a>
<a class=button href=https://ncatelli.github.io/index.xml>Subscribe</a></nav><main class=main><section id=single><h1 class=title>Intro to BGP with BIRD</h1><div class=tip><time datetime="2020-06-13 00:00:00 +0000 UTC">Jun 13, 2020</time>
<span class=split>¬∑</span>
<span>2883 words</span>
<span class=split>¬∑</span>
<span>14 minute read</span></div><aside class=toc><details><summary>Table of Contents</summary><div><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#setup>Setup</a></li><li><a href=#login-in-to-your-playground>Login in to your playground</a></li><li><a href=#bgp-overview>BGP Overview</a><ul><li><a href=#terminology>Terminology</a></li></ul></li><li><a href=#introduction-to-bird>Introduction to BIRD</a><ul><li><a href=#examining-sessions>Examining Sessions</a></li><li><a href=#configuring-a-bgp-session>Configuring a BGP Session</a></li></ul></li><li><a href=#advertising-routes-with-bgp>Advertising Routes with BGP</a><ul><li><a href=#kernel-protocol>Kernel Protocol</a></li><li><a href=#discovering-direct-routes>Discovering direct routes</a></li><li><a href=#filtering-imports-and-exports>Filtering imports and exports</a></li><li><a href=#announcing-routes-with-bird>Announcing Routes with BIRD</a></li></ul></li><li><a href=#next-steps>Next steps</a></li></ul></nav></div></details></aside><div class=content><h2 id=introduction>Introduction <a href=#introduction class=anchor>üîó</a></h2><p>Border Gateway Protocol (BGP) is one of the core technologies involved in making our internet work, allowing networks to communicate their routes among eachother. Understanding how this tool can be used to define the topology of a network will both give you a better understanding of how internetworking and allow you translate this robustness into your own network.</p><p>By the end of this tutorial, you will be familiar with the core concepts of BGP and have the proper vocabulary to communicate this to another network engineer. You will also be able to use a userland routing daemon, BIRD, to establish peering sessions and begin announcing routes.</p><p>I plan to achieve this using a virtualized docker playground which can be downloaded <a href=https://github.com/ncatelli/bird_examples_docker.git target=_blank rel=noopener>here</a>
. In order to complete this tutorial you will need to ensure you have docker and docker-compose installed.</p><h2 id=setup>Setup <a href=#setup class=anchor>üîó</a></h2><p>To begin, you will need to clone the repo of the <a href=https://github.com/ncatelli/bird_examples_docker.git target=_blank rel=noopener>bird_examples_docker</a> project.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ncatelli@ofet&gt; git clone https://github.com/ncatelli/bird_examples_docker.git
</span></span><span style=display:flex><span>ncatelli@ofet&gt; cd bird_examples_docker
</span></span><span style=display:flex><span>ncatelli@ofet&gt; docker-compose up -d
</span></span></code></pre></div><p>This should create three containers (peer1, peer2 and peer3), all of which have BIRD installed and have peering sessions established. Don&rsquo;t worry if you don&rsquo;t know what this means yet, we will cover it shortly after we have our BGP playground set up and ready to go.</p><h2 id=login-in-to-your-playground>Login in to your playground <a href=#login-in-to-your-playground class=anchor>üîó</a></h2><p>We will start by connecting to peer1 and checking that everything was setup correctly.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ncatelli@ofet&gt; docker-compose exec peer1 bash
</span></span><span style=display:flex><span>root@peer1:/# birdc show protocols
</span></span><span style=display:flex><span>BIRD 1.6.6 ready.
</span></span><span style=display:flex><span>name     proto    table    state  since       info
</span></span><span style=display:flex><span>kernel1  Kernel   master   up     02:36:03    
</span></span><span style=display:flex><span>device1  Device   master   up     02:36:03    
</span></span><span style=display:flex><span>direct1  Direct   master   up     02:36:03    
</span></span><span style=display:flex><span>peer2    BGP      master   up     02:36:08    Established   
</span></span><span style=display:flex><span>peer3    BGP      master   up     02:36:07    Established    
</span></span></code></pre></div><p>If you see that peer2 and peer3 are &ldquo;Established&rdquo;, everything is working as expected and we are ready to go. Before we begin playing with this playground, I will provide a brief overview of how BGP works.</p><h2 id=bgp-overview>BGP Overview <a href=#bgp-overview class=anchor>üîó</a></h2><h3 id=terminology>Terminology <a href=#terminology class=anchor>üîó</a></h3><p>Border Gateway Protocol (<a href=https://en.wikipedia.org/wiki/Border_Gateway_Protocol target=_blank rel=noopener>BGP</a>) is an exterior gateway protocol that is used to exchange routing information between autonomous systems. An autonomous system (<a href=https://en.wikipedia.org/wiki/Autonomous_system_%28Internet%29 target=_blank rel=noopener>AS</a>) is an organizational unit of routing prefixes and policies. These AS are identified by a unique 16-bit, and later 32-bit, autonomous system number (ASN). For example, Facebook&rsquo;s ASN would be 32934 or as commonly presented AS32934. The power of BGP lies in its ability to communicate routing protocols and policies among tens of thousands of decentralized AS.</p><p>The internet, along with many other networks, is composed of many autonomous systems that communicate between each other. This communication is facilitated by a peering session, which allows two AS to exchange policies, routes and link status. All of this information is exchanged between two BGP daemons, which will be listening on TCP port 179.</p><p>While BGP is considered an exterior gateway protocol that is used for routing between large organizations on the internet, it can also be used within an AS to enable their network engineers to control the topology of their internal network. This is where the terms exterior BGP (eBGP) and interior BGP (iBGP) stem from. iBGP will be our focus for the rest of this tutorial. We will now start experimenting with these peering sessions using BIRD and its interactive command-line tool, birdc.</p><h2 id=introduction-to-bird>Introduction to BIRD <a href=#introduction-to-bird class=anchor>üîó</a></h2><p>BIRD is a fully-functional routing daemon that supports many different routing protocols, including BGP. BIRD provides a simple configuration format and command line utility for interacting with sessions. BIRD also comes with built-in support for both IPv4 and IPv6 and the respective tools to work with both protocols.</p><h3 id=examining-sessions>Examining Sessions <a href=#examining-sessions class=anchor>üîó</a></h3><p>Similiar to how we verified that our docker environment was provisioned properly, we can view running sessions by running:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@peer1:/# birdc show protocols
</span></span><span style=display:flex><span>BIRD 1.6.6 ready.
</span></span><span style=display:flex><span>name     proto    table    state  since       info
</span></span><span style=display:flex><span>kernel1  Kernel   master   up     02:36:02    
</span></span><span style=display:flex><span>device1  Device   master   up     02:36:02    
</span></span><span style=display:flex><span>direct1  Direct   master   up     02:36:02    
</span></span><span style=display:flex><span>peer2    BGP      master   up     02:36:07    Established   
</span></span><span style=display:flex><span>peer3    BGP      master   up     02:36:06    Established         
</span></span></code></pre></div><p>This gives us a lot of information. However, let us focus on the last two entries, peer2 and peer3. We can see that they are both BGP protocols and that the info field is Established. Each of these entries correspond to a BGP session that peer1 has open with peer2 and peer3. To demonstrate the relationship of these values to our running sessions, let&rsquo;s stop the bird service on peer2. In a new terminal window run the following to stop peer2, simulating a network failure.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ncatelli@ofet&gt; docker-compose stop peer2
</span></span><span style=display:flex><span>Stopping bird_examples_peer2_1 ... <span style=color:#66d9ef>done</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@peer1:/# birdc show protocols
</span></span><span style=display:flex><span>BIRD 1.6.6 ready.
</span></span><span style=display:flex><span>name     proto    table    state  since       info
</span></span><span style=display:flex><span>kernel1  Kernel   master   up     02:36:02    
</span></span><span style=display:flex><span>device1  Device   master   up     02:36:02    
</span></span><span style=display:flex><span>direct1  Direct   master   up     02:36:02    
</span></span><span style=display:flex><span>peer2    BGP      master   start  02:43:38    Connect       Socket: Connection closed
</span></span><span style=display:flex><span>peer3    BGP      master   up     02:36:06    Established  
</span></span></code></pre></div><p>By restarting peer2, a BIRD should restart and subsequently the peering session should be reestablished.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ncatelli@ofet&gt; docker-compose start peer2
</span></span><span style=display:flex><span>Starting peer2 ... <span style=color:#66d9ef>done</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@peer1:/# birdc show protocols
</span></span><span style=display:flex><span>BIRD 1.6.6 ready.
</span></span><span style=display:flex><span>name     proto    table    state  since       info
</span></span><span style=display:flex><span>kernel1  Kernel   master   up     02:36:02    
</span></span><span style=display:flex><span>device1  Device   master   up     02:36:02    
</span></span><span style=display:flex><span>direct1  Direct   master   up     02:36:02    
</span></span><span style=display:flex><span>peer2    BGP      master   up     02:46:29    Established   
</span></span><span style=display:flex><span>peer3    BGP      master   up     02:36:06    Established    
</span></span></code></pre></div><p>By stopping the bird daemon on peer2, we have made the TCP connection on port 179 close between peer1 and peer2. Doing this changes our peer session from Established to Connect. Established and Connect correspond to two of many BGP states, however for the sake of this tutorial we will focus only on Established and consider all other values as not-established. For those more curious, more information on session states can be found in the <a href=https://en.wikipedia.org/wiki/Border_Gateway_Protocol#Finite-state_machines target=_blank rel=noopener>wikipedia article on BGP</a>.</p><h3 id=configuring-a-bgp-session>Configuring a BGP Session <a href=#configuring-a-bgp-session class=anchor>üîó</a></h3><p>Although we now know how to check whether our session are up in our BGP playground, it&rsquo;s also important to understand how these sessions were configured in the first place. For that, we need to dig into the bird configuration files. Let&rsquo;s look at the configuration files under /etc/bird on peer1.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@peer1:~# cat /etc/bird/bird.conf
</span></span><span style=display:flex><span>router id 10.0.0.10;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>protocol kernel <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  metric 0;
</span></span><span style=display:flex><span>  import none;
</span></span><span style=display:flex><span>  learn;
</span></span><span style=display:flex><span>  export all;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>protocol device <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>protocol direct <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>protocol bgp peer2 <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  local as 64512;
</span></span><span style=display:flex><span>  neighbor 10.0.0.11 as 64513;
</span></span><span style=display:flex><span>  import all;
</span></span><span style=display:flex><span>  export all;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>protocol bgp peer3 <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  local as 64512;
</span></span><span style=display:flex><span>  neighbor 10.0.100.11 as 64514;
</span></span><span style=display:flex><span>  import all;
</span></span><span style=display:flex><span>  export all;
</span></span></code></pre></div><p>We can see that the configuration required to establish these initial sessions is very minimal. Let&rsquo;s dig deeper into what actually makes this work. For that, we will focus on one specific block. Our protocol bgp peer2 block:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>protocol bgp peer2 <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  local as 64512;
</span></span><span style=display:flex><span>  neighbor 10.0.0.11 as 64513;
</span></span><span style=display:flex><span>  import all;
</span></span><span style=display:flex><span>  export none;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Earlier in this tutorial, we discussed the difference between eBGP and iBGP and how large AS identify themselves with a unique ASN. However, a small section of the available ASN have been reserved for private iBGP use. This range is 64512 - 65534. Knowing this, we can see that we have allocated a ASN from the private range to our peer2. This <em>local as</em> statement refers to the ASN of your local machine. In this case, peer1 is assigned the ASN 64512.</p><p>Looking at the next statement, we can see a neighbor statement with both an IP and an additional AS. This IP corresponds to the host, or neighbor in BGP lingo, that we are attempting to establish a session with, while the AS 64513 corresponds to the AS we&rsquo;ve assigned to the host, peer2. We can confirm this by looking at the configuration file on peer2.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@peer2:/# grep -A4 peer1 /etc/bird/bird.conf
</span></span><span style=display:flex><span>protocol bgp peer1 <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  local as 64513;
</span></span><span style=display:flex><span>  neighbor 10.0.0.10 as 64512;
</span></span><span style=display:flex><span>  export none;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>It is these two directives in our protocol BGP blocks that handle the initial establishment of sessions.</p><p>While establishing and maintaining sessions is crucial to the operation of BGP, established sessions alone will not allow you to route any traffic. In the next section, we will explore some of the other elements of our configuration files and how we can use them to discover and announce routes between our nodes. Before we proceed with doing this. I&rsquo;d like to review our current topology.</p><p>Currently we have three nodes in our network, peer1 (AS64512), peer2 (AS64513) and peer3 (AS64514). These are configured in the same broadcast domain however the peering is structured like peer3 &lt;-> peer1 &lt;-> peer2. This structure allows communication of routes from either peer2 or peer3 through our route server, peer1. Please keep this topology in mind as we proceed with the next step of this tutorial, advertising routes.</p><h2 id=advertising-routes-with-bgp>Advertising Routes with BGP <a href=#advertising-routes-with-bgp class=anchor>üîó</a></h2><h3 id=kernel-protocol>Kernel Protocol <a href=#kernel-protocol class=anchor>üîó</a></h3><p>Before we begin announcing routes between bird daemons, we should first understand how BIRD communicates routes between the linux kernel and the BIRD daemon. This is where that kernel protocol block we saw earlier comes into play.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>protocol kernel {
</span></span><span style=display:flex><span>  metric 0;
</span></span><span style=display:flex><span>  learn;
</span></span><span style=display:flex><span>  import none;
</span></span><span style=display:flex><span>  export all; 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There are many options that can be specified in the kernel block, and more information on those can be found <a href="http://bird.network.cz/?get_doc&f=bird-6.html#ss6.6" target=_blank rel=noopener>here</a>, however the bulk of what we want to do is defined by the import/export definitions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>import none;
</span></span></code></pre></div><p>Tells BIRD to not read routes in from the kernel routing table into BIRD. We will be obtaining our routes via the direct protocol which we will configure shortly.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>export all;
</span></span></code></pre></div><p>Tells BIRD to export all routes learned by other announcements into the kernel&rsquo;s routing table. This allows us to actually leverage any learned routes on this host.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>metric 0;
</span></span></code></pre></div><p>The metric value is used by the linux kernel to determine the priority of a route, picking the one with the lowest priority. In this case we have set it to an 0 or undefined so that we prefer local routes.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>learn;
</span></span></code></pre></div><p>Finally, we will set the <em>learn</em> directive which will allow other daemons to learn about routes from the kernel routing table.</p><h3 id=discovering-direct-routes>Discovering direct routes <a href=#discovering-direct-routes class=anchor>üîó</a></h3><p>Now that we have configured our BIRD daemons to push routes directly to the kernel routing table, we will need to configure our peers to discover local direct routes. Since we will be adding these routes directly to our loopback interface, in your editor of choice, let&rsquo;s configure the direct protocol to only use the lo interface.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ncatelli@ofet&gt; grep -A2 direct conf/peer2/etc/bird/bird.conf
</span></span><span style=display:flex><span>protocol direct <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  interface <span style=color:#e6db74>&#34;lo&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>ncatelli@ofet&gt; docker-compose restart peer2
</span></span><span style=display:flex><span>Restarting bird_examples_peer2_1 ... <span style=color:#66d9ef>done</span>
</span></span></code></pre></div><p>Since we also have peer3 on our network, let&rsquo;s do the same on this host to prevent any other routes from being announced.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ncatelli@ofet&gt; grep -A2 direct conf/peer3/etc/bird/bird.conf
</span></span><span style=display:flex><span>protocol direct <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  interface <span style=color:#e6db74>&#34;lo&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>ncatelli@ofet&gt; docker-compose restart peer3
</span></span><span style=display:flex><span>Restarting bird_examples_peer3_1 ... <span style=color:#66d9ef>done</span>
</span></span></code></pre></div><p>At this point, we will have no routes learned or announced other than our default 10.0.0.0 subnets, which can be verified with birdc.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@peer2:/# birdc show route all
</span></span><span style=display:flex><span>BIRD 1.6.6 ready.
</span></span><span style=display:flex><span>10.0.0.0/24        via 10.0.0.10 on eth0 <span style=color:#f92672>[</span>peer1 03:05:02<span style=color:#f92672>]</span> ! <span style=color:#f92672>(</span>100<span style=color:#f92672>)</span> <span style=color:#f92672>[</span>AS64512i<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>        Type: BGP unicast univ
</span></span><span style=display:flex><span>        BGP.origin: IGP
</span></span><span style=display:flex><span>        BGP.as_path: <span style=color:#ae81ff>64512</span>
</span></span><span style=display:flex><span>        BGP.next_hop: 10.0.0.10
</span></span><span style=display:flex><span>        BGP.local_pref: <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>10.0.100.0/24      via 10.0.0.10 on eth0 <span style=color:#f92672>[</span>peer1 03:05:02<span style=color:#f92672>]</span> * <span style=color:#f92672>(</span>100<span style=color:#f92672>)</span> <span style=color:#f92672>[</span>AS64512i<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>        Type: BGP unicast univ
</span></span><span style=display:flex><span>        BGP.origin: IGP
</span></span><span style=display:flex><span>        BGP.as_path: <span style=color:#ae81ff>64512</span>
</span></span><span style=display:flex><span>        BGP.next_hop: 10.0.0.10
</span></span><span style=display:flex><span>        BGP.local_pref: <span style=color:#ae81ff>100</span>
</span></span></code></pre></div><h3 id=filtering-imports-and-exports>Filtering imports and exports <a href=#filtering-imports-and-exports class=anchor>üîó</a></h3><p>Similar to the kernel module, export and import can be used to control what is imported and exported by a BGP peer. Let&rsquo;s begin by exploring the concept of filtering and how it can be used to control what routes will be announced or exported.</p><p>Filters in BIRD are basically functions that execute on routes, returning either <em>accept</em> or <em>reject</em>. This allows us to apply a simple programming language to add logic to our routing policies. Filters can contain anything from a single statement to very complex logic. To begin, let&rsquo;s reimplement our none and all directives as filters, adding them to our bird.conf file above the include directive.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>filter accept_all {
</span></span><span style=display:flex><span>  accept;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>filter reject_all {
</span></span><span style=display:flex><span>  reject;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Now that we have our filters in place, let&rsquo;s implement them in our import/export directives for one of our protocol blocks. On your host, peer1, lets look at the block for protocol bgp peer2.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>protocol bgp peer2 {
</span></span><span style=display:flex><span>  local as 64512;
</span></span><span style=display:flex><span>  neighbor 10.0.0.11 as 64513;
</span></span><span style=display:flex><span>  import filter accept_all;
</span></span><span style=display:flex><span>  export filter accept_all;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Functionally, this is identical to our original configuration, however now we can extend these settings with further logic. The power of these filters can be understood by researching the <a href="http://bird.network.cz/?get_doc&f=bird-5.html" target=_blank rel=noopener>filter scripting language</a> further. To expand on what we have learned, let&rsquo;s create a filter in our bird.conf on peer2 to control routes we want to announce to peer1.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>filter export_subnets {
</span></span><span style=display:flex><span>  if net ~ [ 192.168.5.5/32 ] then {
</span></span><span style=display:flex><span>    accept;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  reject;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>and finally we will need to update our protocol bgp peer1 on peer2 to use this export filter.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@peer2:/# grep -A4 peer1 /etc/bird/bird.conf
</span></span><span style=display:flex><span>protocol bgp peer1 <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  local as 64513;
</span></span><span style=display:flex><span>  neighbor 10.0.0.10 as 64512;
</span></span><span style=display:flex><span>  export filter export_subnets; 
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ncatelli@ofet&gt; docker-compose restart peer1 peer2
</span></span><span style=display:flex><span>Restarting bird_examples_peer2_1 ... <span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span>Restarting bird_examples_peer1_1 ... <span style=color:#66d9ef>done</span>
</span></span></code></pre></div><h3 id=announcing-routes-with-bird>Announcing Routes with BIRD <a href=#announcing-routes-with-bird class=anchor>üîó</a></h3><p>We now have all the building blocks we need to begin announcing routes between peer1 and peer2. Before we do that, let&rsquo;s recap what we have done. To begin, we&rsquo;ve configured the BIRD daemon to communicate between its internal routing tables and the kernel routing tables with our kernel protocol. We&rsquo;ve configured the BIRD daemon to learn routes from the loopback interface with the direct protocol. We&rsquo;ve also configured peer1 to import routes from the other peers and export those routes. Finally we configured peer2 to only export <code>192.168.5.5/32</code> to peer1 with our export_subnets filter. However, at this point we have no routes currently announced from peer2 to peer1.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@peer1:/# ip route  
</span></span><span style=display:flex><span>default via 10.0.0.1 dev eth0 
</span></span><span style=display:flex><span>10.0.0.0/24 dev eth0 proto kernel scope link src 10.0.0.10 
</span></span><span style=display:flex><span>10.0.100.0/24 dev eth1 proto kernel scope link src 10.0.100.10
</span></span></code></pre></div><p>Since we&rsquo;ve set up all the building blocks to learn our routes from from the loopback interface. We should be able to directly announce a route by adding an IP to the loopback on peer2.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@peer2:/# ip a add 192.168.5.5/32 dev lo
</span></span></code></pre></div><p>Now if we look at both birdc and the kernel routing table on peer1 we should begin to see routes on peer1 to this new IP.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@peer1:~# ip route
</span></span><span style=display:flex><span>default viia 10.0.2.2 dev eth0
</span></span><span style=display:flex><span>10.0.0.0/24 dev eth1 proto kernel scope link src 10.0.0.10
</span></span><span style=display:flex><span>10.0.2.0/24 dev eth0 proto kernel scope link src 10.0.2.15
</span></span><span style=display:flex><span>10.0.100.0/24 dev eth2 proto kernel scope link src 10.0.100.10
</span></span><span style=display:flex><span>192.168.5.5 via 10.0.0.11 dev eth1 proto bird
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@peer1:/# birdc show route all
</span></span><span style=display:flex><span>BIRD 1.6.6 ready.
</span></span><span style=display:flex><span>10.0.0.0/24        dev eth0 <span style=color:#f92672>[</span>direct1 03:10:33<span style=color:#f92672>]</span> * <span style=color:#f92672>(</span>240<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        Type: device unicast univ
</span></span><span style=display:flex><span>10.0.100.0/24      dev eth1 <span style=color:#f92672>[</span>direct1 03:10:33<span style=color:#f92672>]</span> * <span style=color:#f92672>(</span>240<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        Type: device unicast univ
</span></span><span style=display:flex><span>192.168.5.5/32     via 10.0.0.11 on eth0 <span style=color:#f92672>[</span>peer2 03:12:39<span style=color:#f92672>]</span> * <span style=color:#f92672>(</span>100<span style=color:#f92672>)</span> <span style=color:#f92672>[</span>AS64513i<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>        Type: BGP unicast univ
</span></span><span style=display:flex><span>        BGP.origin: IGP
</span></span><span style=display:flex><span>        BGP.as_path: <span style=color:#ae81ff>64513</span>
</span></span><span style=display:flex><span>        BGP.next_hop: 10.0.0.11
</span></span><span style=display:flex><span>        BGP.local_pref: <span style=color:#ae81ff>100</span>
</span></span></code></pre></div><p>A ping will show that we can now send traffic to this host from peer1.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@peer1:/# ping -c <span style=color:#ae81ff>1</span> 192.168.5.5
</span></span><span style=display:flex><span>PING 192.168.5.5 <span style=color:#f92672>(</span>192.168.5.5<span style=color:#f92672>)</span> 56<span style=color:#f92672>(</span>84<span style=color:#f92672>)</span> bytes of data.
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 192.168.5.5: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.135 ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>--- 192.168.5.5 ping statistics ---
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span> packets transmitted, <span style=color:#ae81ff>1</span> received, 0% packet loss, time 0ms
</span></span><span style=display:flex><span>rtt min/avg/max/mdev <span style=color:#f92672>=</span> 0.135/0.135/0.135/0.000 ms
</span></span></code></pre></div><p>We can also see that we can now see that these routes are being announced on to peer3 via peer1.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@peer3:/# birdc show route all
</span></span><span style=display:flex><span>BIRD 1.6.6 ready.
</span></span><span style=display:flex><span>10.0.0.0/24        via 10.0.100.10 on eth0 <span style=color:#f92672>[</span>peer3 03:10:37<span style=color:#f92672>]</span> * <span style=color:#f92672>(</span>100<span style=color:#f92672>)</span> <span style=color:#f92672>[</span>AS64512i<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>        Type: BGP unicast univ
</span></span><span style=display:flex><span>        BGP.origin: IGP
</span></span><span style=display:flex><span>        BGP.as_path: <span style=color:#ae81ff>64512</span>
</span></span><span style=display:flex><span>        BGP.next_hop: 10.0.100.10
</span></span><span style=display:flex><span>        BGP.local_pref: <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>10.0.100.0/24      via 10.0.100.10 on eth0 <span style=color:#f92672>[</span>peer3 03:10:37<span style=color:#f92672>]</span> ! <span style=color:#f92672>(</span>100<span style=color:#f92672>)</span> <span style=color:#f92672>[</span>AS64512i<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>        Type: BGP unicast univ
</span></span><span style=display:flex><span>        BGP.origin: IGP
</span></span><span style=display:flex><span>        BGP.as_path: <span style=color:#ae81ff>64512</span>
</span></span><span style=display:flex><span>        BGP.next_hop: 10.0.100.10
</span></span><span style=display:flex><span>        BGP.local_pref: <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>192.168.5.5/32     via 10.0.100.10 on eth0 <span style=color:#f92672>[</span>peer3 03:12:38<span style=color:#f92672>]</span> * <span style=color:#f92672>(</span>100<span style=color:#f92672>)</span> <span style=color:#f92672>[</span>AS64513i<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>        Type: BGP unicast univ
</span></span><span style=display:flex><span>        BGP.origin: IGP
</span></span><span style=display:flex><span>        BGP.as_path: <span style=color:#ae81ff>64512</span> <span style=color:#ae81ff>64513</span>
</span></span><span style=display:flex><span>        BGP.next_hop: 10.0.100.10
</span></span><span style=display:flex><span>        BGP.local_pref: <span style=color:#ae81ff>100</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@peer3:/# ping -c <span style=color:#ae81ff>1</span> 192.168.5.5
</span></span><span style=display:flex><span>PING 192.168.5.5 <span style=color:#f92672>(</span>192.168.5.5<span style=color:#f92672>)</span> 56<span style=color:#f92672>(</span>84<span style=color:#f92672>)</span> bytes of data.
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 192.168.5.5: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>63</span> time<span style=color:#f92672>=</span>0.082 ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>--- 192.168.5.5 ping statistics ---
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span> packets transmitted, <span style=color:#ae81ff>1</span> received, 0% packet loss, time 0ms
</span></span><span style=display:flex><span>rtt min/avg/max/mdev <span style=color:#f92672>=</span> 0.082/0.082/0.082/0.000 ms
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@peer3:/# traceroute 192.168.5.5
</span></span><span style=display:flex><span>traceroute to 192.168.5.5 <span style=color:#f92672>(</span>192.168.5.5<span style=color:#f92672>)</span>, <span style=color:#ae81ff>64</span> hops max
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>1</span>   10.0.100.10  0.005ms  0.003ms  0.003ms 
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2</span>   192.168.5.5  0.003ms  0.003ms  0.003ms
</span></span></code></pre></div><p>We can tell this is happening by viewing the AS PATH. By looking at the AS PATH associated with the route in birdc we can see that the route announced from 64513 to 64512 before reaching peer3.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>BGP.as_path: <span style=color:#ae81ff>64512</span> <span style=color:#ae81ff>64513</span>
</span></span></code></pre></div><p>Because peer1 was configured to export routes to peer3, and because peer3 was configured to import routes from peer1, we were able to get this route into the BIRD routing table on peer3. Then, because we have the kernel protocol configured to export routes in BIRD, these routes will make it into the kernel routing table on peer3.</p><h2 id=next-steps>Next steps <a href=#next-steps class=anchor>üîó</a></h2><p>We&rsquo;ve explored many concepts in this simple tutorial, however we&rsquo;ve barely scratched the surface of what bird and, by extension, BGP can do. Feel free to use this playground to further experiement with announcing and filtering routes. In later tutorials, we will dig deeper into how BGP works and the processes it uses to determine routes, including what communities and local preference are and how these can be used by your BGP daemon to choose the best path to a server. We will also explore what an anycasted IP is and how we can configure high-availability with BGP as well as how we can use filtering policies, in place of our direct interface policies, to control what prefixes are announced to each node. BGP can give you a significant amount of control over the topology of your network and understanding how to use it will allow you to better shape your network to how you see fit.</p></div><div class=tags><a href=https://ncatelli.github.io/tags/tutorial>tutorial</a>
<a href=https://ncatelli.github.io/tags/networking>networking</a></div></section></main><footer id=footer><div id=social><a class=symbol href=https://github.com/ncatelli/ rel=me target=_blank><svg fill="#bbb" width="28" height="28" viewBox="0 0 72 72" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>Github</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)"><g id="Github" transform="translate(264.000000, 939.000000)"><path d="M8 72H64c4.418278.0 8-3.581722 8-8V8c0-4.418278-3.581722-8-8-8H8c-4.418278 811624501e-24-8 3.581722-8 8V64c541083001e-24 4.418278 3.581722 8 8 8z" id="Rounded" fill="#bbb"/><path d="M35.9985 13C22.746 13 12 23.7870921 12 37.096644c0 10.6440272 6.876 19.6751861 16.4145 22.8617681C29.6145 60.1797862 30.0525 59.4358488 30.0525 58.7973276 30.0525 58.2250681 30.0315 56.7100863 30.0195 54.6996482c-6.6765 1.4562499-8.085-3.2302544-8.085-3.2302544-1.0905-2.7829884-2.664-3.5239139-2.664-3.5239139C17.091 46.4500754 19.4355 46.4801943 19.4355 46.4801943c2.4075.1701719 3.675 2.4833051 3.675 2.4833051 2.142 3.6820383 5.6175 2.6188404 6.9855 2.0014024C30.3135 49.4077535 30.9345 48.3460615 31.62 47.7436831 26.2905 47.1352808 20.688 45.0691228 20.688 35.8361671c0-2.6308879.9345-4.781379 2.4705-6.4665327C22.911 28.7597262 22.0875 26.3110578 23.3925 22.9934585c0 0 2.016-.6475568 6.6 2.4697516C31.908 24.9285993 33.96 24.6620468 36.0015 24.6515052 38.04 24.6620468 40.0935 24.9285993 42.0105 25.4632101c4.581-3.1173084 6.5925-2.4697516 6.5925-2.4697516C49.9125 26.3110578 49.089 28.7597262 48.8415 29.3696344 50.3805 31.0547881 51.309 33.2052792 51.309 35.8361671c0 9.2555448-5.6115 11.29309-10.9575 11.8894446.860999999999997.7439374 1.629 2.2137408 1.629 4.4621184C41.9805 55.4089489 41.9505 58.0067059 41.9505 58.7973276 41.9505 59.4418726 42.3825 60.1918338 43.6005 59.9554002 53.13 56.7627944 60 47.7376593 60 37.096644 60 23.7870921 49.254 13 35.9985 13" fill="#fff"/></g></g></g></svg></a></div><div class=copyright></div></footer></body></html>